\input{./ost-summary-template.tex}

\newcommand{\TITLE}{Web Engineering 3}
\newcommand{\AUTHOR}{Mona Panchaud}
\newcommand{\INSTITUTE}{Ostschweizer Fachhochschule}


\begin{document}

\begin{multicols*}{2}

\includegraphics[width=0.8\linewidth]{traditional_lifecycle}

\section{SPA Overview}
Plain HTML/CSS/JS Code (no plugin), No page reloads,
Working back button,
Bookmarkable Links,
(limited) offline functionality,
Uses RESTful Services for data access

\textbf{Vorteile}: Usability, keine Page reloads, schneller nach Erstladen (Daten über REST).
\textbf{Nachteile}: Kein direkter Hardware-Zugriff, längere Erstladezeit, Applikationen tendenziell ineffizienter, komplexere Deployment-Strategien, SEO eingeschränkt, JavaScript Abhängigkeit

\includegraphics[width=.6\linewidth]{spa_arch}

\subsection{Routing}
Browser fakes the URL change.
\\
Use \textbf{Anchors \#} or \textbf{window.history} API

\subsection{Dependency Injection}
\begin{itemize}
    \item Reduced coupling between consumer and impl.
    \item Classes relate to each other not directly but by interfaces
    \item Allows flexible replacement of implementation
\end{itemize}

\subsection{Bundling with WebPack}
\begin{description}
    \item[Entry] Startpunkt wo Webpack mit Bundling beginnt und
    Dependencies findet.
    \item[Output] Where to bundle your application.
    \item[Loaders] Transformiert Dateien in Module. (\textit{module})
    \item[Mode] Enable built-in \textit{optimization} mechanisms.
\end{description}

\section{React}

Komponenten werden in Virtual DOM gerendert.

Virtual DOM Änderungen werden verglichen, erst dann werden wirkliche DOM Knoten erstellt.

Präsentations Komponenten \& Container Komponenten (stateful, Logik)

\subsection{JSX}
JSX wird vom Präprozessor zu \mintinline{jsx}|React.createElement| Aufrufen umgewandelt => React import nötig!
\begin{minted}{jsx}
import React from 'react'

const menu = entries.map(entry =>
<ListItem as="a" to={`/${entry.path}`}>
<h1>{entry.title.toUpperCase()}</h1>
<p className="lg">{entry.subtitle}</p>
</ListItem>
);
\end{minted}

\subsubsection{Conditionals}
\begin{minted}{jsx}
{ error &&
    <Message>Fehler: {error}</Message> }
{ error ? <span>Fehler: {error}</span> : <span>OK!</span> }
\end{minted}

\subsubsection{Function \& Const}
\begin{minted}{jsx}
function HelloMessage(props) {
  return <div>Hi {props.name}</div>;
}
const HelloMessage = (props) => <div>Hi {props.name}</div>;
\end{minted}

\subsection{Mounting}
Komponenten müssen gemounted werden damit diese angezeigt werden können.
\begin{minted}{jsx}
const root = ReactDOM.createRoot(
  document.getElementById('root'));
root.render(<App />);
\end{minted}

\subsection{Props}
Alle Parameter sind in \textbf{props} Objekt. Read-only!

\subsection{State}
\begin{itemize}
    \item \textbf{useState} immer in derselben Reihenfolge aufrufen!
    \item Keine von Props abgeleiteten Daten im State!
    \item Props bevorzugen!
    \item Nur Dinge, die für GUI gebraucht werden in State
\end{itemize}

\begin{minted}{jsx}
const [value, setValue] = useState(0);
const increment = () => setCounter(counter + 1);
return <button onClick={increment}>Inc</button>
\end{minted}

\subsection{Formular}
\begin{minted}{jsx}
function handleSubmit(event) {
  // Damit Browser nicht Formular absendet
  event.preventDefault();
  alert(username + "," + password);//ajax
}
// ...
<button type="submit" onClick={handleSubmit}>Login</button>
\end{minted}

\subsection{Lifecycle}
Zusammengehörender Code auf mehrere Methoden verteilt:

\textit{Mount}: constructor -> render -> componentDidMount

\textit{Update}: render -> componentDidUpdate

\textit{Unmount}: componentWillUnmount

\begin{minted}{jsx}
useEffect(() => {
  const timerID = setInterval(
    () => setDate(new Date()), 1000);
  return () => { clearInterval(timerID) }
}, [])
\end{minted}

\subsection{Router}
\begin{minted}{jsx}
<BrowserRouter> // all routes inside tag
<Routes>
  <Route index element={<Home/>} />
  <Route path="/help" element ={<Help/>}/>
</Routes> // auch verschachtelung möglich
// don't use a tags now:
<Link to="/help">Help/Link>
\end{minted}

\subsection{Context}
\begin{minted}{jsx}
const ThemeContext = // param is default
  React.createContext(themes.light);
<ThemeContext.Provider value={themes.dark}>
</ThemeContext.Provider>
const theme = useContext(ThemeContext);
\end{minted}
\begin{itemize}
    \item ideal für globale read-only Props wie Themes
    \item Callbacks können auch durchgereicht werden
    \item Code wird bei vielen Context unübersichtlich
\end{itemize}

\subsection{Redux}
\begin{itemize}
    \item Action: \mintinline{javascript}|{ type: TRANSFER, amount: 100 }|
    \item Reducer erstellt neuen State-Tree mit Daten in Action
    \item Reducer sind pure Funktionen (no side effects)
    \item Reducer nur für Teil (Slice) von State-Tree zuständig
    \item Reducer werden zu Root Reducer kombiniert \mintinline{jsx}|combineReducers({balance, transactions})|
    \item Store wird mit Root Reducer erstellt \mintinline{jsx}|const store = createStore(rootReducer)|
    \item Einfachere Handhabung mit Redux Toolkit! (\mintinline{js}|createSlice({...})| Funktion, Immer library)
\end{itemize}

\subsubsection{Redux Toolkit}
\begin{minted}{js}
const balanceSlice = createSlice({
  name: "balance",
  initialState: { value: 0 },
  reducers: {
    transfer: (state, action) => {
      // "Immer" (Copy & Update Strategie)
      state.value += action.payload.amount;
    },
  },
});
export const {transfer} = balanceSlice.actions;
\end{minted}

\begin{itemize}
    \item Daten von API mit Redux Thunk laden (Middleware)
\end{itemize}

\subsubsection{Redux Vorteile/Nachteile}
\begin{itemize}
    \item Bessere Übersicht: State ist an einer Stelle
    \item Zustand kann serialisiert werden, ermöglicht Server Rendering
    \item Besseres Debugging da explizite Stateänderungen
    \item Einfachere React Komponenten!
    \item Hat \textbf{Overhead}! \(\Rightarrow\) Wenn kaum State existiert, der von mehreren Komponenten verwendet wird, lohnt sich Redux Overhead nicht
    \item Nicht jeder State muss ins Redux.\\Formulardaten/UI-State kann auch React State sein
\end{itemize}

\section{Angular}
für lang lebende \& komplexe Applikationen

\subsection{Modules}
\begin{minted}[breaklines]{ts}
@NgModule ({
  exports : [Type1, Type2, Module1] // The subset of declarations that should be visible and usable in the component templates of other modules.
  imports : [ CommonModule ], // Specifies modules from which exports / providers should be imported into this module.
  declarations : [] , // The view classes that belong to this module (components, directives and pipes ).
  providers : [] , // Creators of services that this module contributes to global collection of services (DI Container); they become accessible in all parts of app.
  bootstrap : [] // Main application view aka the root component. Only root module should set this property.
})
export class CoreModule { }
\end{minted}

\subsubsection{Group Exports}
Um zu vermeiden, dass exportierte Komponenten zweimal angegeben werden müssen!
\begin{minted}{ts}
const EXPORTED_DECLARATIONS: any[] = [Type1];
const INTERNAL_DECLARATIONS: any[] =
  [...EXPORTED_DECLARATIONS, Type2 ];
const EXPORTS: any[] = [...EXPORTED_DECLARATIONS, Module1];

declarations: INTERNAL_DECLARATIONS
exports: EXPORTS
\end{minted}

\subsubsection{Lazy Modules}
Make sure to not reference classes/components/... from Lazy Module from eagerly loaded application part. Otherwise it is already loaded!

\subsubsection{Module Types}
\begin{description}
    \item[Root/App] Provide entry point/bootstrap component for app. Imports BrowserModule. No exports.
    \item[Feature] Specify clear boundaries between application features. Allows to assign dev responsibilities to different teams.
    \item[Shared] Common components/directives/pipes and shares them with feature module. Don't specify app-wide singleton services here! (lazy-loaded module makes its own copy)
    \item[Core] Keeps Root Module clean. Contains components/directives/pipes used by Root Module. Globally used services can be declared here. Only Root Module should import this module.
\end{description}

\paragraph{Feature Module Sub Types}
\begin{description}
    \item[Domain] Deliver UI dedicated to particular app domain
    \item[Routing] Specifies routing specific configuration settings of Feature (or Root) module
    \item[Service] Provides utility services such as data access and messaging
    \item[Widget] Makes components/directive/pipes available to external modules
    \item[Lazy] Represents lazily loaded Feature Modules. (Routed Modules)
\end{description}

\subsection{Components}
\begin{itemize}
    \item Components allow to separate UI logic from representation
    \item Provide Information Hiding: Each Component declares a part of the UI
    \item \lstinline|selector| used to embed component into other view. (tag name (should be prefixed to avoid collisions!) or CSS-selector (\mintinline{css}|'#topHeader'|))
\end{itemize}

\begin{minted}{ts}
@Component({
  selector: 'wed-navigation',
  templateUrl: './navigation.component.html',
  styleUrls: ['./navigation.component.css']
})
export class NavigationComponent {}
\end{minted}

\subsubsection{Template Syntax}
\begin{itemize}
    \item Almost all valid HTML5 syntax is valid template syntax. But \mintinline{html}|<script>| is forbidden!
    \item HTML must be in valid format (\mintinline{html}|<p><h1></h1></p>| is not allowed)
    \item Operators with side effects/chaining are prohibited in "\mintinline{html+ng2}|{{}}|" Expressions (\mintinline{ts}|++ -- new = += , ...|)
\end{itemize}

\subsubsection{Binding}
\begin{description}
    \item[One-way in] Model to view \mintinline{html+ng2}|<p>{{counter.team}}</p>|, \\
      \mintinline{html+ng2}|<img [attr.alt]="counter.team" src="...">|
    \item[One-way call] View to Model (Event Binding) \\ \mintinline{html+ng2}|(click)="counter.eventHandler($event)"|
    \item[Two-way] \mintinline{html+ng2}|[(ngModel)]="counter.team"|
\end{description}

\subsubsection{Input and Output Properties}
\begin{description}
    \item[@Output()] component/directive fires bindable events
    \item[@Input()] component/directive consumes bindable values
\end{description}
\mintinline{html+ng2}|<wed-nav (click)=".." [title]=".."></wed->|
\begin{minted}{ts}
@Component({/*omitted*/})
export class NavigationComponent {
    @Output() click = new EventEmitter<any>();
    @Input() title: string;
}
\end{minted}

\subsubsection{Component Lifecycle}
ctor -> ngOnChanges -> ngOninit -> ngDoCheck -> ngOnDestroy

Do something in lifecycle: Implement hook methods. (interface e.g. \lstinline|OnInit| not needed but recommended)

\subsubsection{Content Projection (like props.children)}
Single-Slot: \mintinline{html+ng2}|<ng-content></ng-content>|

Multi-Slot:
\mintinline[breaklines]{html+ng2}|<ng-content select='menu'></ng-content>| \\
(or with tags: \mintinline{html+ng2}|select='[wed-title]'|)

\subsection{Directives}
\subsubsection{Attribute Directives}
\mintinline{html+ng2}|<div [ngClass]="hasWarning ? 'warn' : '' ">|
\subsubsection{Structural Directives}
\begin{itemize}
    \item Reshapes DOM structure (add, del, change elems)
\end{itemize}
\mintinline{html+ng2}|<div *ngIf="hasTitle"></div>|

\mintinline{html+ng2}|<li *ngFor="let element of elements"></li>|


\subsection{Template Reference Variables}
Reference DOM Element within template. Can also be reference to Angular component or directive.
\begin{minted}{html+ng2}
<input placeholder="phone number" #phone>
<button (click)="makeCall(phone.value)">Call</button>
\end{minted}

\subsection{Services}
\lstinline|@Injectable| marks class as an Injectable instance

\subsubsection{providedIn: root}
\begin{minted}{ts}
@Injectable({ providedIn: 'root' })
export class CounterService {}
\end{minted}
\mintinline{ts}|{providedIn: 'root'}| means service is registered for whole app. But this service is Tree-shakable.

\subsubsection{forRoot() / forChild()}
Create forRoot and forChild methods in module. In forRoot place service into providers. In forChild have no providers. forRoot should only be called from the AppModule / or CoreModule as it's only imported from AppModule.
\subsubsection{Async Services}
Use EventEmitter: \mintinline{ts}|this.xChanged.emit(this.x);|
\begin{minted}[breaklines]{ts}
// subscribe in ngOnInit and unsubscribe in ngOnDestroy
this.xService.xChanged.subscribe((x: XModel) => {this.x = x;});
\end{minted}

\subsection{Forms}
Template Driven and Reactive.

\subsubsection{Reactive Forms}
Form and Validation logic in Controller. Easier to test. Handles async validations. Designed for "daily" use.

\subsubsection{Template-driven Forms}
Less code but validation logic in HTML. More intuitive, simpler. Useful for small forms.

\begin{minted}[breaklines]{html+ng2}
<input type="text" id="name" required
  [(ngModel)]="model.name" name="name"
  #nameField="ngModel">
<div [hidden]="nameField.valid || nameField.pristine"
  >Name required</div>

<form (ngSubmit)="doLogin(sampleForm)" #sampleForm="ngForm">
  <button type="submit" [disabled]="!sampleForm.form.valid">Submit</button>
<form>
\end{minted}

\subsection{Angular Routing}
Define routes for a Module in their own RoutingModule.
Use RouterModule.\textbf{forRoot}(routes) only once on top level. Use \textbf{forChild}(routes) for sub-routing on all sub-levels.
\textbf{forRoot} contains all directive, given routes \textit{AND} singleton router service instance. \textbf{forChild} contains only directives, routes.

Use \mintinline{html+ng2}|<a routerLink="/home">| for links.

\mintinline{html+ng2}|<router-outlet>| defines where router should display views.
Can also be used in child.

\subsubsection{Route Configuration}
Router uses first-match-wins! More specific should be placed above less specific routes. Wildcard should abe last route! Use guards if route should only be activated in certain circumstances.

\textbf{pathMatch: 'full'} exact match.
\textbf{redirectTo: '/heroes'} redirect.
\textbf{path: '**'} wildcard.
\textbf{path: 'hero/:id'} maps e.g. /hero/42.

\subsection{Observables / HttpClient}
2 types with same API but different behavior:

\textbf{Hot Observables} for sequence of events, shared among all subscribers.
\textbf{Cold Observables} start running on subscribption (e.g. web requests), not shared among subscribers, automatically closed after task is finished

\textbf{Data Resource Services} should provide Observable interface.
\textbf{Business Layer Services} subscribe to the provided Observables. Allows caching, filtering, data aggregation and other business logic.

Intercept HTTP Requests with \textit{HttpInterceptor} for e.g. Authorization header.

\subsection{Streaming based business services}
It is possible to pull RxJS through all layers (Ui / Service / Data Resource). But in the end, this will result in async sections within the UI \(\Rightarrow\) Complex data management.

\subsection{Pipe Operator}
Pipes are good choice for small transformations. Can be chained.

\textbf{Custom Pipe}: Also add to declarations of module. Use @Pipe decorator.

async pipes make UI more complex.

\textbf{Predefined Pipes}: AsyncPipe, DecimalPipe, DatePipe, PercentPipe.

\textbf{No Filter / OrderBy pipe}. As these would need to be impure and therefore would perform very poorly. And they prevent aggressive minifcation. Do filtering/sorting inside controller.

\begin{minted}{html+ng2}
<p>{{counter.team | uppercase}}</p>
<p>{{counter.date | date:'longDate'}}</p>
\end{minted}

\begin{description}
    \item[Pure] By default. Only executed when Angular detects \textit{pure change} to input expression. Changes within composite objects/values are ignored.
    \item[Impure] Executed on \textit{every} component change detection cycle (every keystroke, mouse-move or other event). To reduce processing time caching is often seen inside impure pipes.
\end{description}

\subsection{Styling}
Selectors of SCSS file are local to that component! By default achieved with prepropressing. Native (Shadow DOM) implementation can be activated with changing encapsulation tag in @Component metadata.

\subsection{AOT}
Automatic when using production build. In Dev Build: uses JIT compiler by default which is delivered to client.

\section{PWA}
\textit{Unterschied zu SPA}: SPAs konzentrieren sich auf Verbesserung der
Benutzererfahrung auf einer einzigen Seite, indem Inhalte dynamisch nachgeladen
werden, kein page refresh. PWAs erweitern das Konzept mit oben genannten
Features, um Erfahrung zu schaffen, die nativen Apps ähnelt.

\textit{Alternative}: Native Applikation. Nicht alle Besucher von Webseite möchten App installieren. 50\% der Personen installieren keine neue App im Monat. Wenige Personen benutzen viele Apps pro Monat.

\textit{Zurück Knopf}: Wenn PWA in Standalone Fenster (Fullscreen) geöffnet wird auf UX achten. Browserspezifische Features gehen verloren.

\begin{description}
    \item[Safe] HTTPS. Push-Api nur über HTTPS möglich. (ausser localhost)
    \item[Responsive] UI für alle Grössen
    \item[Progressive] neuste APIs nutzen für beste UX ohne ältere Browser zu ignorieren (Progressive Enhancement)
    \item[Linkable] Teilen von Inhalten ohne, dass Sharing Partner App installieren muss
    \item[Discoverable] Webseite soll über Suchmaschinen auffindbar sein.
    \item[Installable] Web Applikation mit Icon auf Startbildschirm speicherbar. (Icon in Web App Manifest, start\_url)
    \item[Network Independent] Webseite soll auch mit schlechter/langsamer/gar keiner Verbindung funktionieren
    \item[Re-engageable] Verbindung zum Benutzer der Seite soll aufgenommen werden können, obwohl Benutzer Seite nicht geöffnet hat (Service Workers, Push-Api)
\end{description}

\section{MobX}
\begin{tabular}{ll}
    \textbf{Redux} & \textbf{Mobx}  \\
    Single Store & Multiple Store \\
    Immutable Store &  Mutable Store\\
    Normalized Date & Denormalized Data \\
    Unidirectional data flow & Unidirectional data flow (empfohlen)
\end{tabular}

\section{ASP.NET}
\textbf{Convention over configuration} Die Anzahl der Entscheidungen, wird verringert, was zu mehr Simplizität führt, ohne notwendigerweise an Flexibilität zu verlieren. Nachteile: Magie, evt Schwer anzupassen falls Anforderungen nicht ins Schema passen

\textbf{Multi-Threading} Besitzt Thread Pool (Grösse konfigurierbar). Wählt für jeden Request einen Thread aus Pool.  Thread solange blockiert bis Request abgeschlossen (oder vorzeitig zurückgegeben: async/await) Keine geteilten Daten in Controller / Services halten (z.B. Static Variablen, ASP.NET instanziert für jeden Request neuen Controller)

\textbf{Front Controller} Routing
\textbf{MVVM} Kommunikation zwischen View und ViewModel über Bindings. View: Markup Language, was User sieht. ViewModel: Value Converter, UI-Logik (Drag\&Drop) Model: Daten, Services, Domain Logik
\textbf{wwwroot} statische Inhalte der Websiete \textbf{appsettings.json} Einstellungen der Webseite (Connection String zur DB) \textbf{Program.cs} Middleware/DI Konfiguration

\subsection{Middleware}
Request durchläuft Stack von Middelwares (Reihenfolge relevant!)

\begin{minted}[breaklines]{cs}
app.Use(async (context, next) => {
    Console.WriteLine("Handling request");
    await next.Invoke();
    Console.WriteLine("Finished handling request.");
});
app.Map("/logging", builder => {
    builder.Run(async (context) => {
        await context.Response.WriteAsync("Hello World!");
    });
});
app.Run(async (context) => {
    await context.Response.WriteAsync("Hello World!");
});
app.UseMiddleware<MyMiddleware>();
public class MyMiddleware {
    public MyMiddleware(RequestDelegate next, ISomething something) { }
    public async Task Invoke(HttpContext context) {
        await _next.Invoke(context);
    }
}
\end{minted}

\subsection{Dependency Injection}
Komponenten dürfen sich \textit{nur} Komponenten mit gleicher oder längerer Laufzeit injecten lassen! (InvalidOperationException)

Bei Registration von mehreren gleichen Services, wird der letzte genommen.
\textbf{Transient} Each time they are requested \textbf{Scoped} Once per request \textbf{Singleton} first time they are requested, same instance afterwards

\subsection{Razor Pages}
\begin{minted}{aspx-cs}
@page
@model HelloWorldModel
<h1>@Model.HelloWorld</h1>
@{ var total = 7; }
<p>The value of your account is: @total </p>
\end{minted}

\subsubsection{Pages Routing}
Mapping von URL nach Convention. Page wird in /pages gesucht.
\textit{/add} \(\Rightarrow\) \textit{/pages/add.cshtml}, \textit{/order/add} \(\Rightarrow\) \textit{/pages/order/add.cshtml}, \textit{/ajax} \(\Rightarrow\) \textit{/pages/ajax/index.cshtml}

Auf Parameter zugreifen in Razor: \mintinline{aspx-cs}|@RouteData.Values["id"]|

\subsubsection{Pages ViewModel (PageModel)}
cshtml.cs. Basis Klasse mit Hilfsfunktionen. Pro HTTP-Verb eine Funktion, die davor aufgerufen wird (OnGet, OnPost, ...)

\begin{minted}{cs}
public class HelloWorldModel : PageModel {
  public string EchoText {get;set;}
  public long Times {get;set;}
  public void OnPost(string echoText, long times) {
    EchoText = echoText;
    Times = times;
  }
  // oder als Klasse
  public void OnPost(EchoModel data) { Data = data; }
  // oder mit [BindProperty], kein OnPost nötig
  // bei Get: [BindProperty(SupportsGet = true)]
}
\end{minted}

\subsubsection{Ajax}

Weitere Handlers in PageModel für Ajax möglich:
\begin{minted}{cs}
public IActionResult OnPostEcho(string echoText) {
    return this.Content(echoText);
}
public IActionResult OnGetAutocomplete(string text) {
    return new JsonResult(_citiesService.GetCities(text));
}
\end{minted}
Können mit [METHOD] /[Page]?handler=[HandlerName] aufgerufen werden (Bsp: GET /Ajax?handler=autocomplete).
Erlaubte Rückgabewerte vom Typ \lstinline|IActionResult|. (JsonResult, NotFoundResult, RedirectToPage). Hilfsmethoden: Page(), Partial(), Content()



\begin{minted}[breaklines]{aspx-cs}
// asp-page-handler setzt "action" Attribute vom Form!
<form asp-page="Ajax" asp-page-handler="Echo" id="echoForm">
  <input name="echoText"/>
  <input type="submit"/>
</form>
// Submit muss mit Javascript gehandelt werden:
const formData = new FormData(args.target); // Anti Forgery Token
const result = await fetch(args.target.action, { method: "post", body: formData });

// JQuery Unobtrusive
<form asp-page="Ajax" asp-page-handler="Echo" id="echoForm" data-ajax="true"
data-ajax-method="POST" data-ajax-mode="replace" data-ajax-update="#echoOutput">
  <input name="echoText"/>
  <input type="submit"/>
</form>
\end{minted}

\subsubsection{Layout}
\textbf{@RenderBody()} wo Content Page gerendert werden soll.

\textbf{@RenderSection("Nav", required: false)} Wo spezifische Section gerendert werden soll. Definiert mit \lstinline|@section Nav {...}|

\textbf{\_ViewStart.cshtml} Code welcher vor Razor Files ausgeführt wird. Definiert zB Layout für alle Pages \lstinline|@{ Layout = "_Layout"; }|

\subsubsection{Validation}
1. Annotieren des ViewModels mit e.g. [Required], [StringLength(60, MinimumLength=3)], [RegularExpression("...")], [DataType(DataType.Date)].

2. Validation ins DOM einfügen und Jquery validation, Jquery validation unobrusive scripts einbinden.
\begin{minted}{aspx-cs}
<div asp-validation-summary="ModelOnly"></div>
<label asp-for="Item.Name"></label>
<input asp-for="Item.Name" />
<span asp-validation-for="Item.Name></span>
<input type="submit" value="Create" />
\end{minted}

3. Server seitige validierung
\begin{minted}{cs}
[HttpPost]
public ActionResult Index(Order order) {
    if (ModelState.IsValid) {
        order.CustomerId = User.Identity.GetUserId();
        db.Orders.Add(order);
        db.SaveChanges();
        return View("OrderOk", order);
    }
    return BadRequest();
}
\end{minted}

\subsection{REST Api}
[HttpMethod] (also HttpGet, HttpPost etc.) Attribut ist bei allen Actions required!
% java is wrong but highlighting gets confused with Route api/[controller] attribute
\begin{minted}{java}
[Route("api/[controller]")]
public class ValuesController : Controller {
    [HttpGet("{id}")]
    public Value Get(int id) {
        return _valueService.Get(id); ;
    }
    [HttpPost]
    // auch direkt [Route("foo")] / [Route("/foo")] möglich
    // oder [HttpPost("foo")] / [HttpPost("/foo")]
    public IActionResult Post([FromBody]Value value) {
        _valueService.Add(value);
        // Location Response Header korrekt setzen auf
        // bspw. localhost:52055/api/Values/4
        return new CreatedAtActionResult("Get", "Values",
          new {id = _valueService.GetId(value)}, value)
    } }
\end{minted}

\subsection{Swagger}
Spezifikation für Dokumentation von REST-Apis, Prog-sprach unabhängig
\begin{minted}{cs}
services.AddSwaggerGen(); // hier kann noch mehr konfiguriert werden.
// bspw: C# XML Kommentare in Swagger oder eine Beschreibung
app.UseSwagger();
app.UseSwaggerUI(options => {
  options.SwaggerEndpoint("/swagger/v1/swagger.json", "XYZ");
});
\end{minted}

\subsection{Exception Handling}
Globalen ErrorHandler definieren für generisches Error Handling, mittels \lstinline|app.UseExceptionHandler(errorApp => errorApp.Run(async context => ...))|, Middleware setzt dann StatusCode und eine für den Client aufbereitete Response (json).

Exception auslösen wenn ModelState nicht valid mittels Filter.
Registration mit: \lstinline|services.AddMvc(opt => { opt.Filters.Add(new XAttribute()) }|
\begin{minted}{cs}
public class ValidateModelAttribute : ActionFilterAttribute {
  public override void OnActionExecuting(
    ActionExecutingContext context) {
    if (!context.ModelState.IsValid) {
      throw new ServiceException(
        ServiceExceptionType.ForbiddenByRule);
    }
  } }
\end{minted}

\subsection{ASP.NET Identity}
Folgende Klassen über DI injectable: \textbf{UserManager<ApplicationUser>}, \textbf{RoleManager<IdentityRole>}, \textbf{IAuthorizationService}: Verantwortlich für Validation von Policies, \textbf{SignInManager}

\textbf{[Authorize]}: User muss authentifiziert sein. \textbf{[AllowAnonymous]}: Für spezifische Action anonymen Zugriff erlauben
\textbf{Manuell überprüfen}: User.Identity.IsAuthenticated

Ein \textbf{Claim} ist Statement über User von IdP ausgestellt

\textit{[Authorize(Roles="Admin,PowerUser")]}, \textit{[Authorize(Policy="OlderThan18")]}

\begin{minted}{cs}
var user = await _userManager.GetUserAsync(User);
var isInRole = await _userManager.IsInRoleAsync(user, "Admin");
var result = await _authorizationService
  .AuthorizeAsync(User, null, "Founders");
var hasClaim = User.HasClaim(ClaimTypes.Role, "Admin");
\end{minted}
\begin{lstlisting}
@inject UserManager<ApplicationUser> manager;
@inject ApplicationDbContext context;
@{
    var user = await manager.GetUserAsync(User);
    if (user != null && await manager.IsInRoleAsync(user, "Administrator")){
        // what should be shown for the Admin
    } }
\end{lstlisting}

\subsection{Integration Test}
\textbf{Pitfalls}: \lstinline|.AddApplicationPart(typeof(Startup).Assembly)| wird für Auffinden von Controllern benötigt.
\lstinline|services.AddDbContext<ApplicationDbContext>(options=>options.UseInMemoryDatabase(_dbId)|
InMemory Datenbank wird beibehalten für alle Tests. Lösung: Jeder Test erhält einen anderen DatenbankNamen (\_dbId).

\section{Blazor}

\section{Web Assembly}
\textbf{Web Assembly} Stack Machine
\textbf{WASM} Compiled Web Assembly, Can be transformed back to WAT
\textbf{WAT} Text Based Web Assembly \lstinline|WebAssembly.instantiateStreaming()| compiles and instantiates a WebAssembly module
\textbf{Instance}: Module paired with all state (incl. Memory, Table and imported values)
\textbf{Memory}: Resizable Array Buffer, at most one Memory is supported
\begin{minted}{wast}
(module
  (func (export "addTwo") (param i32 i32) (result i32)
    local.get 0
    local.get 1
    i32.add)
  )
\end{minted}


\end{multicols*}
\end{document}