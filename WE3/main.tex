\input{./ost-summary-template.tex}

\newcommand{\TITLE}{Web Engineering 3}
\newcommand{\AUTHOR}{Mona Panchaud}
\newcommand{\INSTITUTE}{Ostschweizer Fachhochschule}


\begin{document}
\begin{multicols*}{4}

\includegraphics[width=0.6\linewidth]{traditional_lifecycle}

\section{SPA Overview}

\begin{minipage}[c]{.6\linewidth}
    \begin{itemize}
        \item Plain HTML/CSS/JS Code \\(no plugin)
        \item No page reloads
        \item Working back button
        \item Bookmarkable Links
        \item (limited) offline functionality
        \item Uses RESTful Services \\for data access
    \end{itemize}
\end{minipage}%
\begin{minipage}[c]{.4\linewidth}
    \includegraphics[width=\linewidth]{spa_arch}
\end{minipage}%
\\ % important

\subsection{Routing}
Browser fakes the URL change.
\\
Use \textbf{Anchors \#} or \textbf{window.history} API

\subsection{Bundling with WebPack}
\begin{description}
    \item[Entry] Startpunkt wo Webpack mit Bundling beginnt und
    Dependencies findet.
    \item[Output] Where to bundle your application.
    \item[Loaders] Transformiert Dateien in Module. (\textit{module})
    \item[Mode] Enable built-in \textit{optimization} mechanisms.
\end{description}

% TODO probably move me somewhere else when we get to Angular. Or remove me completely
\subsection{Dependency Injection}
\begin{itemize}
    \item Reduced coupling between consumer and impl.
    \item Classes relate to each other not directly but by interfaces
    \item Allows flexible replacement of implementation
\end{itemize}

\section{React}

\subsection{JSX}
JSX wird vom Präprozessor zu \mintinline{jsx}|React.createElement| Aufrufen umgewandelt => React import nötig!
\begin{minted}{jsx}
import React from 'react'

const menu = entries.map(entry =>
  <ListItem as="a" to={`/${entry.path}`}>
    <h1>{entry.title.toUpperCase()}</h1>
    <p className="lg">{entry.subtitle}</p>
  </ListItem>
);
\end{minted}

\subsubsection{Conditionals}
\begin{minted}{jsx}
{ error &&
    <Message>Fehler: {error}</Message> }
{ error ? <span>Fehler: {error}</span>
        : <span>OK!</span>             }
\end{minted}

\subsubsection{Function \& Const}
\begin{minted}{jsx}
function HelloMessage(props) {
  return <div>Hi {props.name}</div>;
}
const HelloMessage =
  (props) => <div>Hi {props.name}</div>;
\end{minted}

\subsection{Mounting}
Komponenten müssen gemounted werden damit diese angezeigt werden können.
\begin{minted}{jsx}
const root = ReactDOM.createRoot(
  document.getElementById('root'));
root.render(<App />);
\end{minted}

\subsection{Props}
Alle Parameter sind in \textbf{props} Objekt. Read-only!

\subsection{State}
\begin{itemize}
    \item \textbf{useState} immer in derselben Reihenfolge aufrufen!
    \item Keine von Props abgeleiteten Daten im State!
    \item Props bevorzugen!
    \item Nur Dinge, die für GUI gebraucht werden in State
\end{itemize}

\begin{minted}{jsx}
const [value, setValue] = useState(0);
const increment =
  () => setCounter(counter + 1);
return
  <button onClick={increment}>Inc</button>
\end{minted}

\subsection{Formular}
\begin{minted}{jsx}
function handleSubmit(event) {
  // Damit Browser nicht Formular absendet
  event.preventDefault();
  alert(username + "," + password);//ajax
}
// ...
<button type="submit"
  onClick={handleSubmit}>Login</button>
\end{minted}

\subsection{Lifecycle}
Zusammengehörender Code auf mehrere Methoden verteilt:

\textit{Mount}: constructor -> render -> componentDidMount

\textit{Update}: render -> componentDidUpdate

\textit{Unmount}: componentWillUnmount

\begin{minted}{jsx}
useEffect(() => {
  const timerID = setInterval(
    () => setDate(new Date()), 1000);
  return () => {
    clearInterval(timerID)
  }
}, [])
\end{minted}

\subsection{Router}
\begin{minted}{jsx}
<BrowserRouter> // all routes inside tag
<Routes>
  <Route index element={<Home/>} />
  <Route path="/help" element ={<Help/>}/>
</Routes> // auch verschachtelung möglich
// don't use a tags now:
<Link to="/help">Help/Link>
\end{minted}

\subsection{Context}
\begin{minted}{jsx}
const ThemeContext = // param is default
  React.createContext(themes.light);
<ThemeContext.Provider value={themes.dark}>
</ThemeContext.Provider>
const theme = useContext(ThemeContext);
\end{minted}
\begin{itemize}
    \item ideal für globale read-only Props wie Themes
    \item Callbacks können auch durchgereicht werden
    \item Code wird bei vielen Context unübersichtlich
\end{itemize}

\subsection{Redux}
\begin{itemize}
    \item Action: \mintinline{javascript}|{ type: TRANSFER, amount: 100 }|
    \item Reducer erstellt neuen State-Tree mit Daten in Action
    \item Reducer sind pure Funktionen (no side effects)
    \item Reducer nur für Teil (Slice) von State-Tree zuständig
    \item Reducer werden zu Root Reducer kombiniert \mintinline{jsx}|combineReducers({balance, transactions})|
    \item Store wird mit Root Reducer erstellt \mintinline{jsx}|const store = createStore(rootReducer)|
\end{itemize}

\subsubsection{Redux Toolkit}
\begin{minted}{js}
const balanceSlice = createSlice({
  name: "balance",
  initialState: { value: 0 },
  reducers: {
    transfer: (state, action) => {
      // "Immer" (Copy & Update Strategie)
      state.value += action.payload.amount;
    },
  },
});
export const {transfer} =
  balanceSlice.actions;
\end{minted}

\begin{itemize}
    \item Daten von API mit Redux Thunk laden (Middleware)
\end{itemize}
% TODO vielleicht noch mehr zu Redux stuff, aber zuerst schauen wie viel andere sachen so an Platz brauchen

\subsubsection{Redux Vorteile/Nachteile}
\begin{itemize}
    \item Bessere Übersicht: State ist an einer Stelle
    \item Zustand kann serialisiert werden, ermöglicht Server Rendering
    \item Besseres Debugging da explizite Stateänderungen
    \item Einfachere React Komponenten!
    \item Hat \textbf{Overhead}! \(\Rightarrow\) Wenn kaum State existiert, der von mehreren Komponenten verwendet wird, lohnt sich Redux Overhead nicht
    \item Nicht jeder State muss ins Redux.\\Formulardaten/UI-State kann auch React State sein
\end{itemize}

\section{Angular}

\section{ASP.NET}

\end{multicols*}
\end{document}