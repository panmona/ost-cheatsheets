\input{./ost-summary-template.tex}

\newcommand{\TITLE}{Betriebssysteme 1}
\newcommand{\AUTHOR}{Mona Panchaud}
\newcommand{\INSTITUTE}{Ostschweizer Fachhochschule}
\begin{document}
\begin{multicols*}{4}

\section{Prozessor}
P. kann nur über Speicherbus mit Umwelt interagieren!
\textbf{schreiben}:
\begin{enumerate}
    \item P. legt Adresse auf Adressbus \& Daten auf Datenbus
    \item P. aktiviert Speicherbus zum Schreiben
\end{enumerate}
\textbf{lesen}:
\begin{enumerate}
    \item P. legt Adresse auf Adressbus
    \item P. aktiviert Speicherbus zum Lesen
    \item Speicher legt Daten auf Datenbus
\end{enumerate}
OpCode: \includegraphics[width=0.1\textwidth]{opcode.png}

\section{Numbers in Assembly}
\begin{description}
    \item[db] Byte, 8 Bit
    \item[dw] Word, 2 Byte, 16 Bit
    \item[dd] Doubleword, 4 Byte, 32 Bit
    \item[dq] Quadword, 8 Byte, 64 Bit
    \item [Double Quadword] 16 Byte, 128 Bit
\end{description}

\section{Byte Order}
Stellen innerhalb Bytes werden nicht vertauscht!
\begin{description}
    \item[Big-Endian] CA | FE -> MSB ist erstes Bit
    \item[Little-Endian] FE | CA -> LSB ist erstes Bit
\end{description}

\section{Labels}
\begin{lstlisting}[language={[x86masm]Assembler}]
text_length: dq after_my_text - my_text
my_text: db 'BSys 1'
after_my_text:
\end{lstlisting}

\section{Register}
\begin{tabular}{llllll}
    63..0 & 31..0 & 15..0 & 15..8 & 7..0\\
    \hline
    RAX & EAX & AX & AH & AL\\
\end{tabular}

\textbf{Weitere:} RCX, RDX, RBX, RSI, RDI, RSP, RBP, R8-R15

% TODO add syscall somewhere?

\section{Memory}
% TODO do I have enough space to add Displacement Adressierung, Scaled-Index-Adressierung & Base Adressierung?
\begin{lstlisting}[language={[x86masm]Assembler}]
mov rax, [0x8000] ; move 8000h into rax
mov rbx, [rax] ; address is in the register rax
mov [0x8000], rax ; move val at rax into 0x8000
; move rbx into rax, no memory access:
mov rax, rbx
; error can't move memory to memory:
mov [0x8000], [0x7000]
\end{lstlisting}
Operanden müssen gleich gross sein.

% TODO: More Assembly constructs
% (e.g. arithmetic operations)
% see saved pages

% TODO take a look later if "subsection" is correct
\subsection{Flags}
CF \& OF werden immer beide von CPU bestimmt.

Carry Flag (CF) == Überlauf bei \textbf{unsigned} Arithmetik

0001 + 1111 = 0000, CF = 1 --> 1 + 15 = 0, CF = 1

Overflow Flag (OF) == Überlauf bei \textbf{signed} Arithmetik

0111 + 0001 = 1000 -> 7 + 1 = -8 (negative prefix)

Zero Flag (ZF) == set when result is 0

Sign Flag == is the highest bit of the result

Parity Flag (PF) == set if lowest byte has even number of bits

\section{Stack (\& Framepointer)}
"Oberstes" Element an kleinster Adresse

-> wächst nach unten

Prozessor überprüft \textbf{keine} obere/untere Grenze!

\includegraphics[width=0.25\textwidth]{rbp_rsp_base_sit.jpg}
\includegraphics[width=0.24\textwidth]{rbp_rsp_preamble_epilogue.jpg}

Argumente sind vor der Rücksprungadresse auf Stack gelandet. Access via: [rbp + 0x10]

\section{Calling Conventions}
Welche Register / Stack für Argumente.

Von Betriebssystem / Compiler bestimmt => unterschiedlich

\section{C}
\subsection{C-Toolchain}
\begin{enumerate}
    \item \textbf{C Präprozessor} -> Bereinigte C-Quelle
    \item \textbf{C Compiler} -> Assembler Datei
    \item \textbf{Assembler} -> Objekt Datei
    \item \textbf{Linker} -> Executable
\end{enumerate}
\subsubsection{Präprozessor}
\begin{enumerate}
    \item Kommentare entfernen \& \ Zeilen zusammensetzen
    \item In Tokens aufteilen (Whitespace, bei a+b nicht nötig, String wird nicht aufgeteilt).

    Bildet grösstmögliches Token
    \item Präprozessor Direktiven ausführen (include, if, ...)

    \& Makros expandieren
\end{enumerate}
\begin{lstlisting}[language=c]
#define XYZ 123
// XYZ wird im Folgenden mit 123 ersetzt
\end{lstlisting}

\subsubsection{Compiler}
Eine C-Datei -> Eine Assemblerdatei

Bezeichner dürfen beliebig oft \underline{deklariert} (int y;) werden. Nur 1x \underline{definiert} (int y = 5;).

\textbf{static}: Variable, die nicht exportiert werden soll

\begin{lstlisting}[language=c]
extern int x; static int x = 5; // Error:
// static Deklaration folgt auf non-static
\end{lstlisting}

Für globale Var wird Speicher fix reserviert. Grösse hängt von Typ ab. globale Var werden exportiert.

\subsubsection{Linker}
Mehrere Assemblerdateien -> Ein Executable

\subsection{Typen, sizeof(t)}
Typinfos nur auf C Sprachlevel

Size infos are dependent on architecture

\subsection{Vorzeichen}
Bei signed MSB: 0=positiv, 1=negativ

Umwandlung von negativer Binärzahl:

Zweierkomplement bilden -> flip + 1

-> 1010 -> 0101 -> 0110

\subsection{Pointers}

\begin{lstlisting}[language=c]
int a = 42;
int *b = &a; // b pointer to a
a = *b + 1; // a = dereference b and add 1
\end{lstlisting}
Incrementing a pointer will skip \textbf{sizeof(t)} Bytes!
\begin{lstlisting}[language=c]
int32_t x;
int32_t *y = &x;
y++; // y wird um 4 erhöht!
\end{lstlisting}
\vspace{2pt}
Pointer Differenz \textbf{nur} bei gleichen Typen!
\begin{lstlisting}[language=c]
int32_t *y = 100;
int32_t *x = 120;
prtdiff_t z = x - y; // z == 5 (5 * 4 Byte)
\end{lstlisting}

\subsection{Numbers in C}
\begin{itemize}
    \item Decimal: 0..9 with \textbf{NO 0 at the start}
    \item Octal: 0..7 with a \textbf{leading 0}
    \item Hex: 0..F with \textbf{leading 0x}
    \item Suffix: the suffic specifies a type:

    l: long, ll: long long, u: unsigned, ul: unsigned long
\end{itemize}

\subsection{Bitwise Operators}
Werden Bit per Bit angewendet:

not: \~{}q | and: q \& p | or: q | p

left shift: q << p ($* 2^m$) | right shift: q >> p ("$/ 2^m$")
\subsection{Logische Operatoren}
not: !q | and: q \&\& p | or: q || p

\subsection{Arithmetische Operationen}
z = x + y -> falls Überlauf: verpufft (kein Carry)

\subsection{Funktionen}
Parameter werden immer kopiert. (call by value)\vspace{2pt}

Bei Pointer als Parameter: Pointer wird kopiert, nicht der Wert dahinter -> Simulation von call by reference.\vspace{2pt}

Rückgabewert kann jeder Typ ausser Array Typen sein. Rückgabewert wird immer kopiert.

\begin{lstlisting}[language=c]
void f ();
void g (void);
f(); // OK
g(); // OK
f(1, 2, 3); // OK. LOL.
g(1, 2, 3); // Fehler -> parameter type is void
\end{lstlisting}

\subsection{printf Identifiers}
\begin{itemize}
    \item \textcolor{teal}{\textbf{sizeof(Integer)} as signed decimal = \%d oder \%i}
    \item \textcolor{teal}{\textbf{sizeof(Integer)} as unsigned decimal = \%u}
    \item \textcolor{teal}{\textbf{sizeof(Integer)} as hexadecimal = \%x or \%U}
    \item \textcolor{teal}{\textbf{sizeof(long)} as signed decimal = \%li}
    \item \textcolor{teal}{\textbf{sizeof(long long)} as signed decimal = \%lli}
    \item \textcolor{teal}{\textbf{sizeof(void *)} as pointer = \%p (hexadecimal)}
    \item \textcolor{teal}{\textbf{sizeof(char *)} as pointer (null terminated) = \%s}
    \item \textcolor{teal}{\textbf{sizeof(double)} as floating point = \%f}
\end{itemize}

\subsection{Datentypen}
Vordefinierte int Typen Aliase:

\cinline{intpr\_t}: Signed Integer Typ in den Adresse passt

\cinline{int8\_t}, \cinline{int16\_t}, \cinline{int32\_t}, \cinline{int64\_t}: Genaue Anzahl der Bits

\cinline{size\_t}: unsigned int -> genug gross für Adressierung von allem Speicher. Sicherer Datentyp iterieren Array.

\subsection{Arrays}
Label of Array used like \textbf{constant} Pointer

\cinline{int32_t a[10]} wird nicht initialisiert (ausser global)

\cinline{int a[4] = { 0x10 }} wird initialisiert

\cinline{a[0]=0x42} ist das gleiche wie \cinline{*a = 0x42}

\subsubsection{Arrays als Parameter}
\begin{itemize}
    \item Werden als Addressen übergeben, auch wenn Parameter als Array Typ deklariert wird
    \item Enthalten \textbf{keine} Information über ihre Grösse
\end{itemize}

\subsection{Strings}
\cinline{char * s = "Hai";} -> \textbf{Literal}, an speziellem Ort gespeichert, durch Wert der Adresse ersetzt, Werte können nicht verändert werden, zusätzlicher Memory für Pointer benötigt

\cinline{char c[] = \{'H', 'a', 'i', '\0'\};} -> Grösse kann hineinkompiliert werden bei sizeof (bei Funktionsaufruf geht dies verloren, da nur Pointer übergeben), Werte können verändert werden, 'c' ist einfach "Label" auf ersten Index

Strings werden als char *s übergeben -> Null terminiert = wir wissen wo sie aufhören

\subsubsection{String Funktionen}
Länge von String: \cinline{strlen (char const *str)}, jedoch potenziell gefährlich wenn zB kein \textbackslash0 kommt

Deshalb: \cinline{strnlen (char const *str, size_t max)}: Bricht nach max Zeichen ab


\subsection{const}
von compiler überprüft, Tricks jedoch möglich, ausser global (Segmentation Fault)\vspace{2pt}

von rechts nach links lesen
\cinline{char const * const * c} -> c is (non-const) pointer to const pointer to const char

wenn 'const' ganz links: \cinline{const char} <=> \cinline{char const}



\end{multicols*}
\end{document}